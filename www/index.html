<!DOCTYPE html>
<html>
<head>
  <title>Leaflet Map</title>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    #map { height: 100vh; }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 9999;
      background: white;
      padding: 8px 12px;
      border-radius: 6px;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      font-family: sans-serif;
    }
    
    #search {
      margin-top: 8px;
    }

    #searchInput {
      width: 180px;
      padding: 4px 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    #searchResults {
      list-style: none;
      margin: 6px 0 0 0;
      padding: 0;
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    #searchResults li {
      padding: 4px 6px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
    }

    #searchResults li:hover {
      background: #f0f0f0;
    }

    #searchResults li:last-child {
      border-bottom: none;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label><input type="checkbox" id="chkBuildings" checked>Buildings</label><br>
    <label><input type="checkbox" id="chkStreets" checked>Streets</label><br>
    <label><input type="checkbox" id="chkAdmins" checked>Admin areas</label><br>
    <label><input type="checkbox" id="chkDynamic" checked>Dynamic</label>

    <div id="search">
      <form onsubmit="onBuildingSearchSubmit(event)">
        <input
          type="text"
          id="searchInput"
          placeholder="Search buildingsâ€¦"
          autocomplete="off"/>
        <button type="submit">Search</button>
      </form>
      <ul id="searchResults"></ul>
    </div>
  </div>

  <div id="map"></div>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([48.836811, 9.258703], 16);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const buildingsLayer = L.layerGroup([], { renderer: L.canvas() }).addTo(map);
    const streetsLayer = L.layerGroup().addTo(map);
    const adminLayer = L.layerGroup().addTo(map);

    // checkboxes
    const chkBuildings = document.getElementById("chkBuildings");
    const chkStreets = document.getElementById("chkStreets");
    const chkAdmins = document.getElementById("chkAdmins");
    const chkDynamic = document.getElementById("chkDynamic");

    const resultsList = document.getElementById("searchResults");

    function onBuildingSearchSubmit(e) {
      e.preventDefault();
      const query = document.getElementById("searchInput").value.trim();
      // console.log("Search query:", query);
    
      resultsList.innerHTML = "";
      
      if (!query) return;

      fetch("/search_buildings", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query: query })
      })
      .then(r => r.json())
      .then(results => {
        console.log("Search results:", results);

         if (!results.length) {
          const li = document.createElement("li");
          li.textContent = "No results";
          li.style.cursor = "default";
          resultsList.appendChild(li);
          return;
        }

        results.forEach(building => {
          const li = document.createElement("li");

          let label = "";
          if (building.address) label += building.address;
          if (building.house_number) label += " " + building.house_number;

          li.textContent = label || "(unnamed building)";

          li.onclick = () => {
            highlightBuilding(building);
          };

          resultsList.appendChild(li);
        });
      })
    }

    function dynamicVisibilityChecked() {
      const checked = chkDynamic.checked;
      chkBuildings.disabled = checked;
      chkStreets.disabled = checked;
      chkAdmins.disabled = checked;

      updateLayers();
    }

    function updateLayers() {
      const boundingBox = getBoundingBox();

      buildingsLayer.clearLayers();
      streetsLayer.clearLayers();
      adminLayer.clearLayers();

      if (chkDynamic.checked) {
        const zoom = map.getZoom();
        if (zoom >= 15) {
          map.addLayer(buildingsLayer);
          fetchBuildings(boundingBox);
        } else {
          map.removeLayer(buildingsLayer);
        }
        
        if (zoom >= 13) {
          map.addLayer(streetsLayer);
          fetchStreets(boundingBox);
        } else {
          map.removeLayer(streetsLayer);
        }

        if (zoom < 13) {
          map.addLayer(adminLayer);
          fetchAdminAreas(boundingBox, true);
        } else {
          map.removeLayer(adminLayer);
        }
      } else {
        if (chkBuildings.checked) {
          map.addLayer(buildingsLayer);
          fetchBuildings(boundingBox);
        } else {
          map.removeLayer(buildingsLayer);
        }

        if (chkStreets.checked) {
          map.addLayer(streetsLayer);
          fetchStreets(boundingBox);
        } else {
          map.removeLayer(streetsLayer);
        }

        if (chkAdmins.checked) {
          map.addLayer(adminLayer);
          fetchAdminAreas(boundingBox, false);
        } else {
          map.removeLayer(adminLayer);
        }
      }
    }

    chkBuildings.onchange = updateLayers;
    chkStreets.onchange = updateLayers;
    chkAdmins.onchange = updateLayers;
    chkDynamic.onchange = dynamicVisibilityChecked;

    function getBoundingBox() {
      const bounds = map.getBounds();
      const sw = bounds.getSouthWest();
      const ne = bounds.getNorthEast();

      const box = {
        swLat: sw.lat,
        swLon: sw.lng,
        neLat: ne.lat,
        neLon: ne.lng
      };

      return box;
    }

    function fetchBuildings(payload) {
      fetch('/buildings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      })
      .then(r => r.json())
      .then(points => {
        points.forEach(([lat, lon, has_street, has_house_number]) => {
          let color = 'blue';
          if (!has_street) {
            color = 'grey';
          } else if (!has_house_number) {
            color = 'green';
          }

          L.circleMarker([lat, lon], {
            radius: 2,
            color: color,
            renderer: buildingsLayer.options.renderer
          }).addTo(buildingsLayer);
        });
      });
    }

    function fetchStreets(payload) {
      fetch('/streets', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      })
      .then(r => r.json())
      .then(streets => {
        streets.forEach(street => {
          const latlngs = street.points.map(p => [p[0], p[1]]);
          L.polyline(latlngs, { color: 'orange', weight: 4 })
            .addTo(streetsLayer)
            .bindPopup(street.name);
        });
      });
    }

    function getAdminLevelForZoom(zoom) {
      if (zoom <= 2) return 1;
      if (zoom <= 4) return 2;
      if (zoom <= 6) return 3;
      if (zoom === 7) return 4;
      if (zoom === 8) return 5;
      if (zoom === 9) return 6;
      if (zoom === 10) return 7;
      if (zoom === 11) return 8;
      return null;
    }

    function fetchAdminAreas(payload, filter_by_level) {
      fetch('/admin_areas', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      })
      .then(r => r.json())
      .then(admin_areas => {
        admin_areas.forEach(admin_area => {
          // console.log("zoom:", zoom, "filter_by_level:", filter_by_level);
          if (filter_by_level) {
            let expectedLevel = getAdminLevelForZoom(map.getZoom());
            //console.log("expectedLevel:", expectedLevel);
            if (!expectedLevel) expectedLevel = admin_area.level;
            if (expectedLevel != admin_area.level) return;
          }

          admin_area.polygons.forEach(ring => {
            const latlngs = ring.map(p => [p[0], p[1]]);
            L.polygon(latlngs, {
              color: 'red',
              weight: 4,
              fillOpacity: 0.1,
              interactive: false
            })
            .addTo(adminLayer)
            .bindPopup(admin_area.name);
          });
        });
      });
    }

    async function fetchNearestBuilding(lat, lon) {
      const response = await fetch('/nearest_building', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ lat: lat, lon: lon })
      });

      const data = await response.json();

      if (!data || !data.lat || !data.lon || !data.distance) {
        return null;
      }

      return data;
    }

    let nearestBuilding = null;
    function highlightBuilding(building) {
      if (!building) return;

      if (nearestBuilding) {
        map.removeLayer(nearestBuilding);
        nearestBuilding = null;
      }

      let popupText = "";
      if (building.address) popupText += building.address;
      if (building.house_number) popupText += " " + building.house_number;

      nearestBuilding = L.circleMarker([building.lat, building.lon], {
        radius: 5,
        color: 'red'
      })
        .addTo(map)
        .bindPopup(popupText)
        .openPopup();

      map.setView([building.lat, building.lon], Math.max(map.getZoom(), 17), {
        animate: true
      });
    }

    async function fetchNearestStreet(lat, lon) {
      const response = await fetch('/nearest_street', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ lat: lat, lon: lon })
      });

      const data = await response.json();

      if (!data || !data.name || !data.points || !data.distance) {
        return null;
      }

      return data;
    }

    let nearestStreet = null;
    function displayNearestStreet(street) {
      if (!street) return;

      let popupText = "";
      if (street.name) popupText += street.name;
      else popupText += "<unknown street>";

      const latlngs = street.points.map(p => [p[0], p[1]]);
      nearestStreet = L.polyline(latlngs, { color: 'red', weight: 8 })
        .addTo(streetsLayer)
        .bindPopup(popupText)
        .openPopup();
    }

    async function fetchNearestAdminArea(lat, lon, filter_by_level) {
      let expectedLevel = getAdminLevelForZoom(map.getZoom());
      if (!expectedLevel) expectedLevel = -1;
      let filter = filter_by_level ? 1 : 0;
      const response = await fetch('/nearest_admin_area', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ lat: lat, lon: lon, filter: filter, expectedLevel: expectedLevel })
      });

      const data = await response.json();
      if (!data || !data.name || !data.polygons || data.distance == null) {
        return null;
      }

      return data;
    }

    let nearestAdminArea = null;
    function displayNearestAdminArea(admin_area) {
      if (!admin_area) return;

      let popupText = admin_area.name || "<unknown admin area>";

      nearestAdminArea = L.layerGroup().addTo(adminLayer);

      admin_area.polygons.forEach(ring => {
        const latlngs = ring.map(p => [p[0], p[1]]);
        L.polygon(latlngs, {
          color: 'green',
          weight: 8,
          fillOpacity: 0.5
        })
        .addTo(nearestAdminArea)
        .bindPopup(popupText)
        .openPopup();;
      });
    }

    map.whenReady(() => {
      dynamicVisibilityChecked();
    });

    map.on('moveend', () => {
      updateLayers();
    });
      
    // NEAREST
    map.on('click', e => {
      // Remove previous markers
      if (nearestBuilding) map.removeLayer(nearestBuilding);
      if (nearestStreet) map.removeLayer(nearestStreet);
      if (nearestAdminArea) map.removeLayer(nearestAdminArea);

      const { lat, lng } = e.latlng;
      let findBuilding = false;
      let findStreet = false;
      let findAdminArea = false;
      
      if (chkDynamic.checked) {
        const zoom = map.getZoom();
        if (zoom >= 15) {
          // Buildings
          findBuilding = true;
        }
        
        if (zoom >= 13) {
          // Streets
          findStreet = true;
        }

        if (zoom < 13) {
          // Admin areas
          findAdminArea = true;
        }
      } else {
        if (chkBuildings.checked) {
          findBuilding = true;
        }

        if (chkStreets.checked) {
          findStreet = true;
        }

        if (chkAdmins.checked) {
          findAdminArea = true;
        }
      }

      if (findBuilding && findStreet && !findAdminArea) {
        fetchNearestBuilding(lat, lng)
        .then(building => {
          fetchNearestStreet(lat, lng)
          .then(street => {
            if (building.distance < street.distance) {
              highlightBuilding(building);
            } else {
              displayNearestStreet(street);
            }
          });
        });
      } else if (findBuilding && !findStreet && !findAdminArea) {
        fetchNearestBuilding(lat, lng)
        .then(building => highlightBuilding(building));
      } else if (!findBuilding && findStreet && !findAdminArea) {
        fetchNearestStreet(lat, lng)
        .then(street => displayNearestStreet(street));
      } else if (findBuilding && findStreet && findAdminArea) {
        fetchNearestBuilding(lat, lng)
        .then(building => {
          fetchNearestStreet(lat, lng)
          .then(street => {
            fetchNearestAdminArea(lat, lng, chkDynamic.checked)
            .then(admin_area => {
              if (building.distance < street.distance) {
                if (admin_area.distance < building.distance) {
                  displayNearestAdminArea(admin_area);
                } else {
                  highlightBuilding(building);
                }
              } else {
                if (admin_area.distance < street.distance) {
                  displayNearestAdminArea(admin_area);
                } else {
                  displayNearestStreet(street);
                }
              }
            });
          });
        });
      } else if (findBuilding && !findStreet && findAdminArea) {
        fetchNearestBuilding(lat, lng)
        .then(building => {
          fetchNearestAdminArea(lat, lng, chkDynamic.checked)
          .then(admin_area => {
            if (building.distance < admin_area.distance) {
              highlightBuilding(building);
            } else {
              displayNearestAdminArea(admin_area);
            }
          });
        });
      } else if (!findBuilding && findStreet && findAdminArea) {
        fetchNearestStreet(lat, lng)
        .then(street => {
          fetchNearestAdminArea(lat, lng, chkDynamic.checked)
          .then(admin_area => {
            if (street.distance < admin_area.distance) {
              displayNearestStreet(street);
            } else {
              displayNearestAdminArea(admin_area);
            }
          });
        });
      } else if (!findBuilding && !findStreet && findAdminArea) {
        fetchNearestAdminArea(lat, lng, chkDynamic.checked)
        .then(admin_area => displayNearestAdminArea(admin_area));
      }
    });
  </script>
</body>
</html>